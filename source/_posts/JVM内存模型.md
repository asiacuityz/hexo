title: JVM内存模型
author: Asia Cui
tags:
  - 道
categories:
  - JVM内存模型
date: 2019-02-16 15:51:00
---
> Java 开发有个很基础的问题，虽然我们平时接触的不多，但是了解它却成为 Java 开发的必备基础——这就是 JVM。在 C++ 中我们需要手动申请内存然后释放内存，否则就会出现对象已经不再使用内存却仍被占用的情况。在 Java 中 JVM 内置了垃圾回收的机制，帮助开发者承担对象的创建和释放的工作，极大的减轻了开发的负担。那是不是我们就不需要了解 JVM 了，显然在做一些优化或者深入研究应用性能的时候，JVM 还是起了很关键的作用的。因此本篇就总结性的描述下 JVM 的内存模型与垃圾回收相关的知识。

本文的主要内容如下：

*   内存模型
*   垃圾回收
*   参考文章

# 内存模型

![](/images/道/20150720152805765.png)

## 模型详解

### 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为**线程私有**的内存。

### Java 虚拟机栈

Java 虚拟机栈（Java Virtual Machine Stacks）也是**线程私有**的，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：**每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。**每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。

### 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。

### 堆

对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。

根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。

### 方法区

方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机**加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。

Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。

## 各部分的功能

这几个存储区最主要的就是栈区和堆区，那么什么是栈什么是堆呢？说的简单点，栈里面存放的是基本的数据类型和引用，而堆里面则是存放各种对象实例的。
![](/images/道/wh_651x-s_286560225.png)

堆与栈分开设计是为什么呢？

*   栈存储了处理逻辑、堆存储了具体的数据，这样隔离设计更为清晰
*   堆与栈分离，使得堆可以被多个栈共享。
*   栈保存了上下文的信息，因此只能向上增长；而堆是动态分配

栈的大小可以通过 - XSs 设置，如果不足的话，会引起 java.lang.StackOverflowError 的异常

#### 栈区

线程私有，生命周期与线程相同。每个方法执行的时候都会创建一个栈帧（stack frame）用于存放 局部变量表、操作栈、动态链接、方法出口。

#### 堆

存放对象实例，所有的对象的内存都在这里分配。垃圾回收主要就是作用于这里的。

*   堆得内存由 - Xms 指定，默认是物理内存的 1/64；最大的内存由 - Xmx 指定，默认是物理内存的 1/4。
*   默认空余的堆内存小于 40% 时，就会增大，直到 - Xmx 设置的内存。具体的比例可以由 - XX:MinHeapFreeRatio 指定
*   空余的内存大于 70% 时，就会减少内存，直到 - Xms 设置的大小。具体由 - XX:MaxHeapFreeRatio 指定。

因此一般都建议把这两个参数设置成一样大，可以避免 JVM 在不断调整大小。

#### 程序计数器

这里记录了线程执行的字节码的行号，在分支、循环、跳转、异常、线程恢复等都依赖这个计数器。

#### 方法区

类型信息、字段信息、方法信息、其他信息

总结

| 名称 | 特征 | 作用 | 配置 | 异常 |
| --- | --- | --- | --- | --- |
| 栈区 | 线程私有，使用一段连续的内存空间 | 存放局部变量表、操作栈、动态链接、方法出口 | -XSs | StackOverflowError OutOfMemoryError |
| 堆 | 线程共享，生命周期与虚拟机相同 | 保存对象实例 | -Xms -Xmx -Xmn | OutOfMemoryError |
| 程序计数器 | 线程私有、占用内存小 | 字节码行号 | 无 | 无 |
| 方法区 | 线程共享 | 存储类加载信息、常量、静态变量等 | -XX:PermSize -XX:MaxPermSize | OutOfMemoryError |

# 垃圾回收

## 如何定义垃圾

有两种方式，一种是引用计数（但是无法解决循环引用的问题）；另一种就是可达性分析。

判断对象可以回收的情况：

*   显示的把某个引用置位 NULL 或者指向别的对象
*   局部引用指向的对象
*   弱引用关联的对象

## 垃圾回收的方法

#### Mark-Sweep 标记 - 清除算法

![](/images/道/341412-20170310115901922-1449104761.png)

这种方法优点就是减少停顿时间，但是缺点是会造成内存碎片。

#### Copying 复制算法

![](/images/道/341412-20170310115901922-1449104762.png)

这种方法不涉及到对象的删除，只是把**标记为可用**的对象从一个地方拷贝到另一个地方，因此适合大量对象回收的场景，比如新生代的回收。

#### Mark-Compact 标记 - 整理算法

![](/images/道/341412-20170310115901922-1449104763.png)

这种方法可以解决内存碎片问题，但是会增加停顿时间。

#### Generational Collection 分代收集

最后的这种方法是前面几种的合体，即目前 JVM 主要采取的一种方法，思想就是把 JVM 分成不同的区域。每种区域使用不同的垃圾回收方法。

![](/images/道/341412-20170310115901922-1449104764.png)

上面可以看到堆分成两个个区域：

*   新生代 (Young Generation)：用于存放新创建的对象，采用复制回收方法，如果在 s0 和 s1 之间复制一定次数后，转移到年老代中。这里的垃圾回收叫做 minor GC;
*   年老代 (Old Generation)：这些对象垃圾回收的频率较低，采用的标记整理方法，这里的垃圾回收叫做 major GC。

这里可以详细的说一下新生代复制回收的算法流程：

在新生代中，分为三个区：Eden, from survivor, to survior。

*   当触发 minor GC 时，会先把 Eden 中存活的对象复制到 to Survivor 中；
*   然后再看 from survivor，如果次数达到年老代的标准，就复制到年老代中；如果没有达到则复制到 to survivor 中，如果 to survivor 满了，则复制到年老代中。
*   然后调换 from survivor 和 to survivor 的名字，保证每次 to survivor 都是空的等待对象复制到那里的。

## 垃圾回收器

![](/images/道/341412-20170310115901922-1449104765.png)

#### 串行收集器 Serial

这种收集器就是以单线程的方式收集，垃圾回收的时候其他线程也不能工作。
![](/images/道/341412-20170310115901922-1449104766.png)

#### 并行收集器 Parallel

以多线程的方式进行收集
![](/images/道/341412-20170310115901922-1449104767.png)

#### 并发标记清除收集器 Concurrent Mark Sweep Collector, CMS

大致的流程为：初始标记 -- 并发标记 -- 重新标记 -- 并发清除

![](/images/道/341412-20170310115901922-1449104768.png)

#### G1 收集器 Garbage First Collector

大致的流程为：初始标记 -- 并发标记 -- 最终标记 -- 筛选回收

![](/images/道/341412-20170310115901922-1449104769.png)

# 参考

*   JVM 内存模型：[http://developer.51cto.com/art/200911/165015.htm](http://developer.51cto.com/art/200911/165015.htm)
*   垃圾回收：[http://www.importnew.com/19085.html](http://www.importnew.com/19085.html)
*   JVM 垃圾回收器：[http://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html](http://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html)
*   内存模型： [http://blog.csdn.net/u012152619/article/details/46968883](http://blog.csdn.net/u012152619/article/details/46968883)